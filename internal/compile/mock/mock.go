package mock

import (
	"fmt"
	"go/ast"
	"go/token"
	"path/filepath"
	"strings"

	"github.com/gardenbed/basil-cli/internal/compile"
	"github.com/gardenbed/basil-cli/internal/ui"
)

const mainPkg = "main"

// New creates a new compiler for generating mockers for interfaces.
func New(ui ui.UI) *compile.Compiler {
	m := new(mocker)
	consumer := &compile.Consumer{
		Name:      "mocker",
		Package:   m.Package,
		FilePre:   m.FilePre,
		FilePost:  m.FilePost,
		Import:    m.Import,
		Interface: m.Interface,
	}

	return compile.New(ui, consumer)
}

type mocker struct {
	imports []ast.Spec
	decls   []ast.Decl
}

func (m *mocker) Package(info *compile.Package, pkg *ast.Package) bool {
	return pkg.Name != mainPkg
}

func (m *mocker) FilePre(info *compile.File, file *ast.File) bool {
	// Reset the state for compiling a new file
	m.imports, m.decls = nil, nil

	return true
}

func (m *mocker) FilePost(info *compile.File, file *ast.File) error {
	if len(m.imports) == 0 && len(m.decls) == 0 {
		return nil
	}

	// Imports
	importDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: m.imports,
	}

	importDecl.Specs = append(importDecl.Specs,
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Value: fmt.Sprintf("%q", info.ImportPath),
			},
		},
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Value: `"github.com/davecgh/go-spew/spew"`,
			},
		},
	)

	newFile := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Slash: 1, Text: "// DO NOT EDIT"},
				{Slash: 16, Text: "// Code generated by Basil"},
			},
		},
		Package: 45,
		Name: &ast.Ident{
			NamePos: 53,
			Name:    info.Package.Name + "test",
		},
		Decls: append([]ast.Decl{importDecl}, m.decls...),
	}

	fileName := strings.Replace(info.Name, ".go", "_mock.go", 1)
	filePath := filepath.Join(info.BaseDir, ".gen", info.RelativeDir+"test", fileName)
	if err := compile.WriteFile(filePath, info.FileSet, newFile); err != nil {
		return err
	}

	return nil
}

func (m *mocker) Import(info *compile.File, spec *ast.ImportSpec) {
	m.imports = append(m.imports, spec)
}

func (m *mocker) Interface(info *compile.Type, node *ast.InterfaceType) {
	decls := []ast.Decl{}
	decls = append(decls, createMockerStructDecl(info.Name))
	decls = append(decls, createMockFuncDecl(info.Name))
	decls = append(decls, createMockerExpectMethodDecl(info.Name))
	decls = append(decls, createMockerImplMethodDecl(info.Package.Name, info.Name))
	decls = append(decls, createMockerAssertMethodDecl(info.Name, node.Methods))
	decls = append(decls, createExpectationsStructDecl(info.Name, node.Methods))
	decls = append(decls, createExpectationsMethodDecls(info.Name, node.Methods)...)

	for _, method := range node.Methods.List {
		if isMethod(method) {
			decls = append(decls, createExpectationStructDecls(method)...)
			decls = append(decls, createExpectationWithArgsMethodDecl(method))
			decls = append(decls, createExpectationReturnMethodDecl(method))
			decls = append(decls, createExpectationCallMethodDecl(method))
		}
	}

	decls = append(decls, createImplStructDecl(info.Name))

	for _, method := range node.Methods.List {
		if isMethod(method) {
			decls = append(decls, createImplMethodDecl(info.Name, method))
		}
	}

	m.decls = append(m.decls, decls...)
}

func createMockerStructDecl(typeName string) ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: typeName + "Mocker",
				},
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{
									{Name: "t"},
								},
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   &ast.Ident{Name: "testing"},
										Sel: &ast.Ident{Name: "T"},
									},
								},
							},
							{
								Names: []*ast.Ident{
									{Name: "spew"},
								},
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   &ast.Ident{Name: "spew"},
										Sel: &ast.Ident{Name: "ConfigState"},
									},
								},
							},
							{
								Names: []*ast.Ident{
									{Name: "expectations"},
								},
								Type: &ast.StarExpr{
									X: &ast.Ident{Name: typeName + "Expectations"},
								},
							},
						},
					},
				},
			},
		},
	}
}

func createMockFuncDecl(typeName string) ast.Decl {
	return &ast.FuncDecl{
		Name: &ast.Ident{
			Name: "Mock" + typeName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							{Name: "t"},
						},
						Type: &ast.StarExpr{
							X: &ast.SelectorExpr{
								X:   &ast.Ident{Name: "testing"},
								Sel: &ast.Ident{Name: "T"},
							},
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.Ident{Name: typeName + "Mocker"},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: &ast.Ident{Name: typeName + "Mocker"},
								Elts: []ast.Expr{
									&ast.KeyValueExpr{
										Key:   &ast.Ident{Name: "t"},
										Value: &ast.Ident{Name: "t"},
									},
									&ast.KeyValueExpr{
										Key: &ast.Ident{Name: "spew"},
										Value: &ast.UnaryExpr{
											Op: token.AND,
											X: &ast.CompositeLit{
												Type: &ast.SelectorExpr{
													X:   &ast.Ident{Name: "spew"},
													Sel: &ast.Ident{Name: "ConfigState"},
												},
												Elts: []ast.Expr{
													&ast.KeyValueExpr{
														Key:   &ast.Ident{Name: "Indent"},
														Value: &ast.BasicLit{Value: `"  "`},
													},
													&ast.KeyValueExpr{
														Key:   &ast.Ident{Name: "DisablePointerAddresses"},
														Value: &ast.Ident{Name: "true"},
													},
													&ast.KeyValueExpr{
														Key:   &ast.Ident{Name: "DisableCapacities"},
														Value: &ast.Ident{Name: "true"},
													},
													&ast.KeyValueExpr{
														Key:   &ast.Ident{Name: "SortKeys"},
														Value: &ast.Ident{Name: "true"},
													},
												},
											},
										},
									},
									&ast.KeyValueExpr{
										Key: &ast.Ident{Name: "expectations"},
										Value: &ast.CallExpr{
											Fun: &ast.Ident{Name: "new"},
											Args: []ast.Expr{
												&ast.Ident{Name: typeName + "Expectations"},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func createMockerExpectMethodDecl(typeName string) ast.Decl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "m"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: typeName + "Mocker"},
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: "Expect",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.Ident{Name: typeName + "Expectations"},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.SelectorExpr{
							X:   &ast.Ident{Name: "m"},
							Sel: &ast.Ident{Name: "expectations"},
						},
					},
				},
			},
		},
	}
}

func createMockerImplMethodDecl(pkgName, typeName string) ast.Decl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "m"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: typeName + "Mocker"},
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: "Impl",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.SelectorExpr{
							X:   &ast.Ident{Name: pkgName},
							Sel: &ast.Ident{Name: typeName},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: &ast.Ident{Name: typeName + "Impl"},
								Elts: []ast.Expr{
									&ast.KeyValueExpr{
										Key: &ast.Ident{Name: "t"},
										Value: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "m"},
											Sel: &ast.Ident{Name: "t"},
										},
									},
									&ast.KeyValueExpr{
										Key: &ast.Ident{Name: "spew"},
										Value: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "m"},
											Sel: &ast.Ident{Name: "spew"},
										},
									},
									&ast.KeyValueExpr{
										Key: &ast.Ident{Name: "expectations"},
										Value: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "m"},
											Sel: &ast.Ident{Name: "expectations"},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func createMockerAssertMethodDecl(typeName string, methods *ast.FieldList) ast.Decl {
	stmts := []ast.Stmt{}

	for _, method := range methods.List {
		if isMethod(method) {
			exportedName := method.Names[0].Name
			unexportedName := compile.ConvertToUnexported(exportedName)

			stmts = append(stmts, &ast.RangeStmt{
				Key:   &ast.Ident{Name: "_"},
				Value: &ast.Ident{Name: "e"},
				Tok:   token.DEFINE,
				X: &ast.SelectorExpr{
					X: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "m"},
						Sel: &ast.Ident{Name: "expectations"},
					},
					Sel: &ast.Ident{Name: unexportedName + "Expectations"},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.IfStmt{
							Cond: &ast.BinaryExpr{
								X: &ast.SelectorExpr{
									X:   &ast.Ident{Name: "e"},
									Sel: &ast.Ident{Name: "recorded"},
								},
								Op: token.EQL,
								Y:  &ast.Ident{Name: "nil"},
							},
							Body: &ast.BlockStmt{
								List: []ast.Stmt{
									&ast.ExprStmt{
										X: &ast.CallExpr{
											Fun: &ast.SelectorExpr{
												X: &ast.SelectorExpr{
													X:   &ast.Ident{Name: "m"},
													Sel: &ast.Ident{Name: "t"},
												},
												Sel: &ast.Ident{Name: "Errorf"},
											},
											Args: []ast.Expr{
												&ast.BasicLit{
													Value: fmt.Sprintf(`"\nExpected %s method be called with %%s"`, exportedName),
												},
												&ast.CallExpr{
													Fun: &ast.SelectorExpr{
														X: &ast.SelectorExpr{
															X:   &ast.Ident{Name: "m"},
															Sel: &ast.Ident{Name: "spew"},
														},
														Sel: &ast.Ident{Name: "Sdump"},
													},
													Args: []ast.Expr{
														&ast.SelectorExpr{
															X:   &ast.Ident{Name: "e"},
															Sel: &ast.Ident{Name: "inputs"},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			})
		}
	}

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "m"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: typeName + "Mocker"},
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: "Assert",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
		},
		Body: &ast.BlockStmt{
			List: stmts,
		},
	}
}

func createExpectationsStructDecl(typeName string, methods *ast.FieldList) ast.Decl {
	fields := &ast.FieldList{}

	for _, method := range methods.List {
		if isMethod(method) {
			if methodName := method.Names[0].Name; compile.IsExported(methodName) {
				unexportedName := compile.ConvertToUnexported(methodName)
				fields.List = append(fields.List, &ast.Field{
					Names: []*ast.Ident{
						{Name: unexportedName + "Expectations"},
					},
					Type: &ast.ArrayType{
						Elt: &ast.StarExpr{
							X: &ast.Ident{Name: methodName + "Expectation"},
						},
					},
				})
			}
		}
	}

	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: typeName + "Expectations",
				},
				Type: &ast.StructType{
					Fields: fields,
				},
			},
		},
	}
}

func createExpectationsMethodDecls(typeName string, methods *ast.FieldList) []ast.Decl {
	decls := []ast.Decl{}

	for _, method := range methods.List {
		if isMethod(method) {
			if methodName := method.Names[0].Name; compile.IsExported(methodName) {
				unexportedName := compile.ConvertToUnexported(methodName)
				decls = append(decls, &ast.FuncDecl{
					Recv: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{
									{Name: "e"},
								},
								Type: &ast.StarExpr{
									X: &ast.Ident{Name: typeName + "Expectations"},
								},
							},
						},
					},
					Name: &ast.Ident{Name: methodName},
					Type: &ast.FuncType{
						Params: &ast.FieldList{},
						Results: &ast.FieldList{
							List: []*ast.Field{
								{
									Type: &ast.StarExpr{
										X: &ast.Ident{Name: methodName + "Expectation"},
									},
								},
							},
						},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.AssignStmt{
								Lhs: []ast.Expr{
									&ast.Ident{Name: "expectation"},
								},
								Tok: token.DEFINE,
								Rhs: []ast.Expr{
									&ast.CallExpr{
										Fun: &ast.Ident{Name: "new"},
										Args: []ast.Expr{
											&ast.Ident{Name: methodName + "Expectation"},
										},
									},
								},
							},
							&ast.AssignStmt{
								Lhs: []ast.Expr{
									&ast.SelectorExpr{
										X:   &ast.Ident{Name: "e"},
										Sel: &ast.Ident{Name: unexportedName + "Expectations"},
									},
								},
								Tok: token.ASSIGN,
								Rhs: []ast.Expr{
									&ast.CallExpr{
										Fun: &ast.Ident{Name: "append"},
										Args: []ast.Expr{
											&ast.SelectorExpr{
												X:   &ast.Ident{Name: "e"},
												Sel: &ast.Ident{Name: unexportedName + "Expectations"},
											},
											&ast.Ident{Name: "expectation"},
										},
									},
								},
							},
							&ast.ReturnStmt{
								Results: []ast.Expr{
									&ast.Ident{Name: "expectation"},
								},
							},
						},
					},
				})
			}
		}
	}

	return decls
}

func createExpectationStructDecls(method *ast.Field) []ast.Decl {
	exportedName := method.Names[0].Name
	unexportedName := compile.ConvertToUnexported(exportedName)

	// isMethod guarantees method.Type is *ast.FuncType
	funcType := method.Type.(*ast.FuncType)
	inputFields := normalizeFieldList(funcType.Params)
	outputFields := normalizeFieldList(funcType.Results)

	return []ast.Decl{
		// Struct
		&ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: &ast.Ident{
						Name: exportedName + "Expectation",
					},
					Type: &ast.StructType{
						Fields: &ast.FieldList{
							List: []*ast.Field{
								{
									Names: []*ast.Ident{
										{Name: "inputs"},
									},
									Type: &ast.StarExpr{
										X: &ast.Ident{Name: unexportedName + "Inputs"},
									},
								},
								{
									Names: []*ast.Ident{
										{Name: "outputs"},
									},
									Type: &ast.StarExpr{
										X: &ast.Ident{Name: unexportedName + "Outputs"},
									},
								},
								{
									Names: []*ast.Ident{
										{Name: "callback"},
									},
									Type: method.Type,
								},
								{
									Names: []*ast.Ident{
										{Name: "recorded"},
									},
									Type: &ast.StarExpr{
										X: &ast.Ident{Name: unexportedName + "Inputs"},
									},
								},
							},
						},
					},
				},
			},
		},
		// Inputs struct
		&ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: &ast.Ident{Name: unexportedName + "Inputs"},
					Type: &ast.StructType{
						Fields: inputFields,
					},
				},
			},
		},
		// Outputs struct
		&ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: &ast.Ident{
						Name: unexportedName + "Outputs",
					},
					Type: &ast.StructType{
						Fields: outputFields,
					},
				},
			},
		},
	}
}

func createExpectationWithArgsMethodDecl(method *ast.Field) ast.Decl {
	exportedName := method.Names[0].Name
	unexportedName := compile.ConvertToUnexported(exportedName)

	// isMethod guarantees method.Type is *ast.FuncType
	funcType := method.Type.(*ast.FuncType)
	inputFields := normalizeFieldList(funcType.Params)
	keyValueList := createKeyValueExprList(funcType.Params)

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "e"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: exportedName + "Expectation"},
					},
				},
			},
		},
		Name: &ast.Ident{Name: "WithArgs"},
		Type: &ast.FuncType{
			Params: inputFields,
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.Ident{Name: exportedName + "Expectation"},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X:   &ast.Ident{Name: "e"},
							Sel: &ast.Ident{Name: "inputs"},
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: &ast.Ident{Name: unexportedName + "Inputs"},
								Elts: keyValueList,
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.Ident{Name: "e"},
					},
				},
			},
		},
	}
}

func createExpectationReturnMethodDecl(method *ast.Field) ast.Decl {
	exportedName := method.Names[0].Name
	unexportedName := compile.ConvertToUnexported(exportedName)

	// isMethod guarantees method.Type is *ast.FuncType
	funcType := method.Type.(*ast.FuncType)
	outputFields := normalizeFieldList(funcType.Results)
	keyValueList := createKeyValueExprList(funcType.Results)

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "e"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: exportedName + "Expectation"},
					},
				},
			},
		},
		Name: &ast.Ident{Name: "Return"},
		Type: &ast.FuncType{
			Params: outputFields,
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.Ident{Name: exportedName + "Expectation"},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X:   &ast.Ident{Name: "e"},
							Sel: &ast.Ident{Name: "outputs"},
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: &ast.Ident{Name: unexportedName + "Outputs"},
								Elts: keyValueList,
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.Ident{Name: "e"},
					},
				},
			},
		},
	}
}

func createExpectationCallMethodDecl(method *ast.Field) ast.Decl {
	exportedName := method.Names[0].Name

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "e"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: exportedName + "Expectation"},
					},
				},
			},
		},
		Name: &ast.Ident{Name: "Call"},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							{Name: "callback"},
						},
						Type: method.Type,
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.Ident{Name: exportedName + "Expectation"},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X:   &ast.Ident{Name: "e"},
							Sel: &ast.Ident{Name: "callback"},
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.Ident{Name: "callback"},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.Ident{Name: "e"},
					},
				},
			},
		},
	}
}

func createImplStructDecl(typeName string) ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: typeName + "Impl",
				},
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{
									{Name: "t"},
								},
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   &ast.Ident{Name: "testing"},
										Sel: &ast.Ident{Name: "T"},
									},
								},
							},
							{
								Names: []*ast.Ident{
									{Name: "spew"},
								},
								Type: &ast.StarExpr{
									X: &ast.SelectorExpr{
										X:   &ast.Ident{Name: "spew"},
										Sel: &ast.Ident{Name: "ConfigState"},
									},
								},
							},
							{
								Names: []*ast.Ident{
									{Name: "expectations"},
								},
								Type: &ast.StarExpr{
									X: &ast.Ident{Name: typeName + "Expectations"},
								},
							},
						},
					},
				},
			},
		},
	}
}

func createImplMethodDecl(typeName string, method *ast.Field) ast.Decl {
	exportedName := method.Names[0].Name
	unexportedName := compile.ConvertToUnexported(exportedName)

	// isMethod guarantees method.Type is *ast.FuncType
	funcType := method.Type.(*ast.FuncType)
	inputFields := normalizeFieldList(funcType.Params)
	outputFields := normalizeFieldList(funcType.Results)

	inputsAssignElts := []ast.Expr{}
	for _, f := range inputFields.List {
		for _, id := range f.Names {
			inputsAssignElts = append(inputsAssignElts, &ast.KeyValueExpr{
				Key:   &ast.Ident{Name: id.Name},
				Value: &ast.Ident{Name: id.Name},
			})
		}
	}

	callbackArgs := []ast.Expr{}
	for _, f := range inputFields.List {
		for _, id := range f.Names {
			callbackArgs = append(callbackArgs, &ast.Ident{Name: id.Name})
		}
	}

	outputResults := []ast.Expr{}
	for _, f := range outputFields.List {
		for _, id := range f.Names {
			outputResults = append(outputResults, &ast.SelectorExpr{
				X: &ast.SelectorExpr{
					X:   &ast.Ident{Name: "e"},
					Sel: &ast.Ident{Name: "outputs"},
				},
				Sel: &ast.Ident{Name: id.Name},
			})
		}
	}

	outputZeroResults := []ast.Expr{}
	for _, f := range outputFields.List {
		for range f.Names {
			outputZeroResults = append(outputZeroResults, createZeroValueExpr(f.Type))
		}
	}

	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "i"},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: typeName + "Impl"},
					},
				},
			},
		},
		Name: &ast.Ident{Name: exportedName},
		Type: &ast.FuncType{
			Params:  inputFields,
			Results: funcType.Results,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.Ident{Name: "inputs"},
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: &ast.Ident{Name: unexportedName + "Inputs"},
								Elts: inputsAssignElts,
							},
						},
					},
				},
				&ast.RangeStmt{
					Key:   &ast.Ident{Name: "_"},
					Value: &ast.Ident{Name: "e"},
					Tok:   token.DEFINE,
					X: &ast.SelectorExpr{
						X: &ast.SelectorExpr{
							X:   &ast.Ident{Name: "i"},
							Sel: &ast.Ident{Name: "expectations"},
						},
						Sel: &ast.Ident{Name: unexportedName + "Expectations"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.IfStmt{
								Cond: &ast.BinaryExpr{
									X: &ast.BinaryExpr{
										X: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "e"},
											Sel: &ast.Ident{Name: "inputs"},
										},
										Op: token.EQL,
										Y:  &ast.Ident{Name: "nil"},
									},
									Op: token.LOR,
									Y: &ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   &ast.Ident{Name: "reflect"},
											Sel: &ast.Ident{Name: "DeepEqual"},
										},
										Args: []ast.Expr{
											&ast.SelectorExpr{
												X:   &ast.Ident{Name: "e"},
												Sel: &ast.Ident{Name: "inputs"},
											},
											&ast.Ident{Name: "inputs"},
										},
									},
								},
								Body: &ast.BlockStmt{
									List: []ast.Stmt{
										&ast.AssignStmt{
											Lhs: []ast.Expr{
												&ast.SelectorExpr{
													X:   &ast.Ident{Name: "e"},
													Sel: &ast.Ident{Name: "recorded"},
												},
											},
											Tok: token.ASSIGN,
											Rhs: []ast.Expr{
												&ast.Ident{Name: "inputs"},
											},
										},
										&ast.IfStmt{
											Cond: &ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   &ast.Ident{Name: "e"},
													Sel: &ast.Ident{Name: "callback"},
												},
												Op: token.NEQ,
												Y:  &ast.Ident{Name: "nil"},
											},
											Body: &ast.BlockStmt{
												List: []ast.Stmt{
													&ast.ReturnStmt{
														Results: []ast.Expr{
															&ast.CallExpr{
																Fun: &ast.SelectorExpr{
																	X:   &ast.Ident{Name: "e"},
																	Sel: &ast.Ident{Name: "callback"},
																},
																Args: callbackArgs,
															},
														},
													},
												},
											},
										},
										&ast.ReturnStmt{
											Results: outputResults,
										},
									},
								},
							},
						},
					},
				},
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X: &ast.SelectorExpr{
								X:   &ast.Ident{Name: "i"},
								Sel: &ast.Ident{Name: "t"},
							},
							Sel: &ast.Ident{Name: "Errorf"},
						},
						Args: []ast.Expr{
							&ast.BasicLit{
								Value: fmt.Sprintf(`"\nExpectation missing: %s method called with %%s"`, exportedName),
							},
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X: &ast.SelectorExpr{
										X:   &ast.Ident{Name: "i"},
										Sel: &ast.Ident{Name: "spew"},
									},
									Sel: &ast.Ident{Name: "Sdump"},
								},
								Args: []ast.Expr{
									&ast.Ident{Name: "inputs"},
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: outputZeroResults,
				},
			},
		},
	}
}
