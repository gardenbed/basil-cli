package builder

import (
	"fmt"
	"go/ast"
	"go/token"
	"path/filepath"
	"strings"

	"github.com/gardenbed/charm/ui"
	"github.com/gardenbed/go-parser"
)

const mainPkg = "main"

// New creates a new compiler for generating builders for structs.
func New(ui ui.UI) *parser.Compiler {
	b := new(builder)
	consumer := &parser.Consumer{
		Name:     "builder",
		Package:  b.Package,
		FilePre:  b.FilePre,
		FilePost: b.FilePost,
		Import:   b.Import,
		Struct:   b.Struct,
	}

	return parser.NewCompiler(ui, consumer)
}

type builder struct {
	imports []ast.Spec
	decls   []ast.Decl
}

func (b *builder) Package(info *parser.Package, pkgName string) bool {
	return pkgName != mainPkg
}

func (b *builder) FilePre(info *parser.File, file *ast.File) bool {
	b.imports, b.decls = nil, nil
	return true
}

func (b *builder) FilePost(info *parser.File, file *ast.File) error {
	if len(b.imports) == 0 && len(b.decls) == 0 {
		return nil
	}

	// Imports
	importDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: b.imports,
	}

	importDecl.Specs = append(importDecl.Specs,
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Value: fmt.Sprintf("%q", info.ImportPath),
			},
		},
		&ast.ImportSpec{
			Path: &ast.BasicLit{
				Value: `"github.com/moorara/acai/value"`,
			},
		},
	)

	newFile := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Slash: 1, Text: "// DO NOT EDIT"},
				{Slash: 16, Text: "// Code generated by Gelato"},
			},
		},
		Package: 45,
		Name: &ast.Ident{
			NamePos: 53,
			Name:    info.Package.Name + "test",
		},
		Decls: append([]ast.Decl{importDecl}, b.decls...),
	}

	fileName := strings.Replace(info.Name, ".go", "_factory.go", 1)
	filePath := filepath.Join(info.BaseDir, ".gen", info.RelativeDir+"test", fileName)
	if err := parser.WriteFile(filePath, info.FileSet, newFile); err != nil {
		return err
	}

	return nil
}

func (b *builder) Import(info *parser.File, spec *ast.ImportSpec) {
	b.imports = append(b.imports, spec)
}

func (b *builder) Struct(info *parser.Type, node *ast.StructType) {
	decls := []ast.Decl{}
	decls = append(decls, createFuncDecl(info.Package.Name, info.Name))
	decls = append(decls, createBuilderStructDecl(info.Package.Name, info.Name))
	decls = append(decls, createBuildFuncDecl(info.Package.Name, info.Name, node.Fields))

	for _, field := range node.Fields.List {
		if len(field.Names) > 0 {
			for _, id := range field.Names {
				// Only consider exported fields
				if parser.IsExported(id.Name) {
					decls = append(decls, createBuilderMethodDecl(info.Name, id, field.Type))
				}
			}
		} else {
			// Embedded field
			id := &ast.Ident{Name: parser.InferName(field.Type)}

			// Only consider exported fields
			if parser.IsExported(id.Name) {
				decls = append(decls, createBuilderMethodDecl(info.Name, id, field.Type))
			}
		}
	}

	decls = append(decls, createBuilderValueDecl(info.Package.Name, info.Name))
	decls = append(decls, createBuilderPointerDecl(info.Package.Name, info.Name))

	b.decls = append(b.decls, decls...)
}

func createFuncDecl(pkgName, typeName string) ast.Decl {
	return &ast.FuncDecl{
		Name: &ast.Ident{Name: typeName},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.SelectorExpr{
							X:   &ast.Ident{Name: pkgName},
							Sel: &ast.Ident{Name: typeName},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X: &ast.CallExpr{
									Fun: &ast.Ident{Name: "Build" + typeName},
								},
								Sel: &ast.Ident{Name: "Value"},
							},
						},
					},
				},
			},
		},
	}
}

func createBuilderStructDecl(pkgName, typeName string) ast.Decl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: typeName + "Builder",
				},
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{
									{Name: "v"},
								},
								Type: &ast.SelectorExpr{
									X:   &ast.Ident{Name: pkgName},
									Sel: &ast.Ident{Name: typeName},
								},
							},
						},
					},
				},
			},
		},
	}
}

func createBuildFuncDecl(pkgName, typeName string, fields *ast.FieldList) ast.Decl {
	elts := []ast.Expr{}

	for _, field := range fields.List {
		if len(field.Names) > 0 {
			for _, id := range field.Names {
				// Only consider exported fields
				if parser.IsExported(id.Name) {
					elts = append(elts, createFieldInitExpr(id, field.Type))
				}
			}
		} else {
			// Embedded field
			id := &ast.Ident{Name: parser.InferName(field.Type)}

			// Only consider exported fields
			if parser.IsExported(id.Name) {
				elts = append(elts, createFieldInitExpr(id, field.Type))
			}
		}
	}

	return &ast.FuncDecl{
		Name: &ast.Ident{
			Name: "Build" + typeName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.Ident{Name: typeName + "Builder"},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.Ident{Name: typeName + "Builder"},
							Elts: []ast.Expr{
								&ast.KeyValueExpr{
									Key: &ast.Ident{Name: "v"},
									Value: &ast.CompositeLit{
										Type: &ast.SelectorExpr{
											X:   &ast.Ident{Name: pkgName},
											Sel: &ast.Ident{Name: typeName},
										},
										Elts: elts,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func createBuilderMethodDecl(typeName string, id *ast.Ident, typ ast.Expr) ast.Decl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "b"},
					},
					Type: &ast.Ident{Name: typeName + "Builder"},
				},
			},
		},
		Name: &ast.Ident{
			Name: fmt.Sprintf("With%s", id.Name),
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							{Name: parser.ConvertToUnexported(id.Name)},
						},
						Type: typ,
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.Ident{Name: typeName + "Builder"},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X: &ast.SelectorExpr{
								X:   &ast.Ident{Name: "b"},
								Sel: &ast.Ident{Name: "v"},
							},
							Sel: &ast.Ident{Name: id.Name},
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.Ident{Name: parser.ConvertToUnexported(id.Name)},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.Ident{Name: "b"},
					},
				},
			},
		},
	}
}

func createBuilderValueDecl(pkgName, typeName string) ast.Decl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "b"},
					},
					Type: &ast.Ident{Name: typeName + "Builder"},
				},
			},
		},
		Name: &ast.Ident{Name: "Value"},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.SelectorExpr{
							X:   &ast.Ident{Name: pkgName},
							Sel: &ast.Ident{Name: typeName},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.SelectorExpr{
							X:   &ast.Ident{Name: "b"},
							Sel: &ast.Ident{Name: "v"},
						},
					},
				},
			},
		},
	}
}

func createBuilderPointerDecl(pkgName, typeName string) ast.Decl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: "b"},
					},
					Type: &ast.Ident{Name: typeName + "Builder"},
				},
			},
		},
		Name: &ast.Ident{Name: "Pointer"},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.StarExpr{
							X: &ast.SelectorExpr{
								X:   &ast.Ident{Name: pkgName},
								Sel: &ast.Ident{Name: typeName},
							},
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.SelectorExpr{
								X:   &ast.Ident{Name: "b"},
								Sel: &ast.Ident{Name: "v"},
							},
						},
					},
				},
			},
		},
	}
}
